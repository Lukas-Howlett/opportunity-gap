# -*- coding: utf-8 -*-
"""OppGapPROJECT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GHzkuD6GbxRWENT_3ZMDHwkrxtINAd2p
"""

import math
from random import Random
from itertools import product

import pandas as pd
import numpy as np
import bokeh as bk
from bokeh.layouts import gridplot, column
from bokeh.plotting import figure, show, ColumnDataSource
from bokeh.models import FactorRange, Div, HoverTool, ColorBar, CheckboxGroup, Legend
from bokeh.models import CategoricalColorMapper, LogColorMapper, LinearColorMapper
from bokeh.models import BasicTicker, NumeralTickFormatter, CustomJS
from bokeh.io import output_notebook
from bokeh.palettes import Blues9, Oranges9, Category10_10, Pastel1_3, Spectral11, RdYlBu11
from bokeh.transform import factor_cmap
from sklearn.cluster import KMeans

output_notebook()

#IMPORT FAKE GRADES FUNCTION
def fake_grades_data(num_datapoints, course1_mean, course2_mean, major_axis_radius, minor_axis_radius, angle):
    major_axis_radius /= 2
    minor_axis_radius /= 2
    var1 = major_axis_radius ** 2 * math.cos(angle) ** 2 + minor_axis_radius ** 2 * math.sin(angle) ** 2
    var2 = major_axis_radius ** 2 * math.sin(angle) ** 2 + minor_axis_radius ** 2 * math.cos(angle) ** 2
    cov12 = (major_axis_radius ** 2 - minor_axis_radius ** 2) * math.sin(angle) * math.cos(angle)
    return pd.DataFrame(
        np.clip(
            np.random.default_rng().multivariate_normal(
                [course1_mean, course2_mean],
                [[var1, cov12], [cov12, var2]],
                num_datapoints,
            ),
            0, 100,
        ),
        columns=['prereq_score', 'subseq_score'],
    )

#IMPORT NUMERIC TO LETTER GRADES CONVERTER
# round numeric grades into letter grades
BOUNDARIES = {
    95: 'A',
    90: 'A-',
    90 - (10/3): 'B+',
    80 + (10/3): 'B',
    80: 'B-',
    80 - (10/3): 'C+',
    70 + (10/3): 'C',
    70: 'C-',
    60: 'D',
    0: 'F',
}

def number_to_letter(number):
    for key, value in BOUNDARIES.items():
        if number >= key:
            return value

def number_to_rank(number):
    for i, key in zip(range(len(BOUNDARIES) - 1, -1, -1), BOUNDARIES):
        if number >= key:
            return i

#IMPORT FAKE DATASET GENERATION
DATAPOINTS = 5000
URM_PERCENT = 0.30

# these variables are for convenience only, as they are determined by the constants above
NUM_URMS = round(URM_PERCENT * DATAPOINTS)
NUM_NONS = DATAPOINTS - NUM_URMS

# create dataframe with numeric grades based on multivariable Gaussian
df = (
    pd.concat([
        fake_grades_data(NUM_URMS, 85, 80, 25, 15, math.pi / 3),
        fake_grades_data(NUM_NONS, 85, 85, 25, 15, math.pi / 3.5),
    ])
    .assign(
        race=[
            'URM' if i < NUM_URMS else 'Non-URM'
            for i in range(DATAPOINTS)
        ],
        prereq_grade=(lambda df: df['prereq_score'].map(number_to_letter)),
        subseq_grade=(lambda df: df['subseq_score'].map(number_to_letter)),
        prereq_rank=(lambda df: df['prereq_score'].map(number_to_rank)),
        subseq_rank=(lambda df: df['subseq_score'].map(number_to_rank)),
    )
)

df.tail()

# Define colors for URM and non-URM students
colors = {'URM': 'blue', 'Non-URM': 'red'}

# Define the dimensions for the parallel coordinates plot
dimensions = ['prereq_score', 'subseq_score']

# Create a ColumnDataSource from the DataFrame
source = ColumnDataSource(df)

# Create the parallel coordinates plot
plot = figure(title="Parallel Coordinates Plot", tools='pan,box_zoom,reset,save',
              x_range=dimensions, y_range=(0, 100), width=800, height=400)

# Plot the red lines (non-URM students)
for index, row in df.iterrows():
    if row['race'] == 'Non-URM':
        plot.line(dimensions, [row[dim] for dim in dimensions], line_color='red', line_width=0.1, alpha=0.5, legend_label=row['race'])

# Plot the blue lines (URM students)
for index, row in df.iterrows():
    if row['race'] == 'URM':
        plot.line(dimensions, [row[dim] for dim in dimensions], line_color='blue', line_width=0.1, alpha=0.5, legend_label=row['race'])

# Customize plot properties
plot.xaxis.axis_label = "Dimensions"
plot.yaxis.axis_label = "Values"
plot.legend.title = "URM Status"

# Show the plot
output_notebook()
show(plot)

# Define colors for URM and non-URM students
colors = {'URM': 'blue', 'Non-URM': 'red'}

# Define the dimensions for the parallel coordinates plot
dimensions = ['prereq_score', 'subseq_score']

# Perform clustering (Didn't end up doing what I wanted but I left in this notebook anyways as part of the process)
# Thought I'd be able to combine similar URM datapoints and non-URM datapoints in order to reduce volume of data on the chart
kmeans = KMeans(n_clusters=2, random_state=0).fit(df[dimensions])

# Add cluster labels to DataFrame
df['cluster'] = kmeans.labels_

# Define colors for clusters
cluster_colors = {1: 'red', 0: 'blue'}

# Create a ColumnDataSource from the DataFrame
source = ColumnDataSource(df)

# Create the parallel coordinates plot
plot = figure(title="Parallel Coordinates Plot", tools='pan,box_zoom,reset,save',
              x_range=dimensions, y_range=(0, 100), width=800, height=400)

# Plot lines for each cluster
for cluster_label, color in cluster_colors.items():
    cluster_df = df[df['cluster'] == cluster_label]
    for index, row in cluster_df.iterrows():
        plot.line(dimensions, [row[dim] for dim in dimensions], line_color=color, alpha=0.5, line_width=0.1)

# Customize plot properties
plot.xaxis.axis_label = "Prerequisite vs. Subsequent"
plot.yaxis.axis_label = "Grade Earned"

# Add legend for URM status
plot.circle([], [], color='blue', legend_label="Blue: URM")
plot.circle([], [], color='red', legend_label="Red: Non-URM")

# Show the plot
show(plot)

# Define the dimensions for the parallel coordinates plot
dimensions = ['prereq_score', 'subseq_score']

# Create the parallel coordinates plot
plot = figure(title="Grade changes in Under-Represented Minority Students (URM) vs. non-URM Students", tools='pan,box_zoom,reset,save',
              x_range=dimensions, y_range=(30, 100), width=600, height=400)

# Plot the red lines (non-URM students)
for index, row in df.iterrows():
    if row['race'] == 'Non-URM':
        plot.line(dimensions, [row[dim] for dim in dimensions], line_color='red', alpha=0.5, legend_label=row['race'], line_width=0.1)

# Plot the blue lines (URM students)
for index, row in df.iterrows():
    if row['race'] == 'URM':
        plot.line(dimensions, [row[dim] for dim in dimensions], line_color='blue', alpha=0.5, legend_label=row['race'], line_width=0.1)

# Customize plot properties
plot.xaxis.axis_label = "Prerequisite vs. Subsequent"
plot.yaxis.axis_label = "Grade Earned"

# Add hover tooltips
hover = HoverTool()
hover.tooltips = [("Prerequisite Score", '@prereq_score'), ("Subsequent Score", '@subseq_score')]
plot.add_tools(hover)

# Create a ColumnDataSource from the DataFrame to insert into checkbox
source = ColumnDataSource(df)

# Define a checkbox group
checkbox_group = CheckboxGroup(labels=["URM", "Non-URM"], active=list(range(2)))

# Filter the data using group_filter
checkbox_group.js_link('active', source, 'selected', attr_selector='line_color')

# Define function to classify grades as improved or worsened
def classify_grade_change(row):
    if row['subseq_score'] >= row['prereq_score']:
        return 'Improved'
    else:
        return 'Worsened'

# Apply the function to create a new column in df to use for bar graph
df['grade_change'] = df.apply(classify_grade_change, axis=1)

# Group data by URM status and grade change
grouped_data = df.groupby(['race', 'grade_change']).size().unstack(fill_value=0)

# Create bar plot for URM vs non-URM
p1 = figure(x_range=['Improved', 'Improved_Non', 'Worsened', 'Worsened_Non'], height=250, title="Grade Change Comparison",
            toolbar_location=None, tools="")

# Extract counts for URM: Yes and No for improved and worsened grades
urm_improved = grouped_data.loc['URM', 'Improved']
urm_worsened = grouped_data.loc['URM', 'Worsened']
non_urm_improved = grouped_data.loc['Non-URM', 'Improved']
non_urm_worsened = grouped_data.loc['Non-URM', 'Worsened']

# Plot bars for URM and non-URM
p1.vbar(x=['Improved'], top=urm_improved, width=0.4, color='blue', legend_label='URM')
p1.vbar(x=['Improved_Non'], top=non_urm_improved, width=0.4, color='red', legend_label='Non-URM')
p1.vbar(x=['Worsened'], top=urm_worsened, width=0.4, color='blue')
p1.vbar(x=['Worsened_Non'], top=non_urm_worsened, width=0.4, color='red')

p1.y_range.start = 0
p1.xgrid.grid_line_color = None
p1.axis.minor_tick_line_color = None
p1.outline_line_color = None
p1.legend.location = "top_left"
p1.legend.orientation = "horizontal"

grid = gridplot([[plot], [p1]])

# Show the plot
output_notebook()
show(column(checkbox_group, grid))

# Define the dimensions for the parallel coordinates plot
dimensions = ['prereq_score', 'subseq_score']

# Create the parallel coordinates plot
plot = figure(title="Grade changes in Under-Represented Minority Students (URM)", tools='pan,box_zoom,reset,save',
              x_range=dimensions, y_range=(30, 100), width=600, height=400)

# Create the parallel coordinates plot
plot2 = figure(title="Grade changes in non-URM Students", tools='pan,box_zoom,reset,save',
              x_range=dimensions, y_range=(30, 100), width=600, height=400)

# Plot the red lines (non-URM students)
for index, row in df.iterrows():
    if row['race'] == 'Non-URM':
        plot2.line(dimensions, [row[dim] for dim in dimensions], line_color='red', legend_label=row['race'], line_width=0.1)

# Plot the blue lines (URM students)
for index, row in df.iterrows():
    if row['race'] == 'URM':
        plot.line(dimensions, [row[dim] for dim in dimensions], line_color='blue', legend_label=row['race'], line_width=0.1)

# Customize plot properties
plot.xaxis.axis_label = "Prerequisite vs. Subsequent"
plot.yaxis.axis_label = "Grade Earned"
plot2.xaxis.axis_label = "Prerequisite vs. Subsequent"
plot2.yaxis.axis_label = "Grade Earned"

# Define function to classify grades as improved or worsened
def classify_grade_change(row):
    if row['subseq_score'] >= row['prereq_score']:
        return 'Improved'
    else:
        return 'Worsened'

# Apply the function to create a new column in df to use for bar graph
df['grade_change'] = df.apply(classify_grade_change, axis=1)

# Group data by URM status and grade change
grouped_data = df.groupby(['race', 'grade_change']).size().unstack(fill_value=0)

# Create bar plot for URM vs non-URM
p1 = figure(title="Percentage improved/worsened for URM and Non-URM", x_range=['% Improved', '% Improved_Non', '% Worsened', '% Worsened_Non'],
            height=250, y_range=(0.0, 1.0), toolbar_location=None, tools="")

# Extract counts for URM: Yes and No for improved and worsened grades
urm_improved = grouped_data.loc['URM', 'Improved']
urm_worsened = grouped_data.loc['URM', 'Worsened']
non_urm_improved = grouped_data.loc['Non-URM', 'Improved']
non_urm_worsened = grouped_data.loc['Non-URM', 'Worsened']

#Get percentages of improved/worsened for each population
urm_improved_percentage = urm_improved/NUM_URMS
urm_worsened_percentage = urm_worsened/NUM_URMS
non_urm_improved_percentage = non_urm_improved/NUM_NONS
non_urm_worsened_percentage = non_urm_worsened/NUM_NONS

# Plot bars for URM and non-URM
p1.vbar(x=['% Improved'], top=urm_improved_percentage, width=0.4, color='blue', legend_label='URM')
p1.vbar(x=['% Improved_Non'], top=non_urm_improved_percentage, width=0.4, color='red', legend_label='Non-URM')
p1.vbar(x=['% Worsened'], top=urm_worsened_percentage, width=0.4, color='blue')
p1.vbar(x=['% Worsened_Non'], top=non_urm_worsened_percentage, width=0.4, color='red')

p1.xgrid.grid_line_color = None
p1.axis.minor_tick_line_color = None
p1.outline_line_color = None
p1.yaxis.axis_label = "% of respective population"
p1.xaxis.axis_label = "Population Group"
p1.legend.location = "top_left"
p1.legend.orientation = "horizontal"

#grid = gridplot([[plot], [plot2], [p1]])

# Show the plot
output_notebook()
#show(column(checkbox_group, grid))
show(gridplot([[plot, plot2], [p1, None]]))

# Define the dimensions for the parallel coordinates plot
dimensions = ['prereq_score', 'subseq_score']

# Create the parallel coordinates plot
plot = figure(title="Grade changes in Under-Represented Minority Students (URM)", tools='pan,box_zoom,reset,save',
              x_range=dimensions, y_range=(30, 100), width=650, height=400)

# Create the parallel coordinates plot
plot2 = figure(title="Grade changes in non-URM Students", tools='pan,box_zoom,reset,save',
              x_range=dimensions, y_range=(30, 100), width=650, height=400)

# Plot the red lines (non-URM students)
for index, row in df.iterrows():
    if row['race'] == 'Non-URM':
        plot2.line(dimensions, [row[dim] for dim in dimensions], line_color='red', legend_label=row['race'], line_width=0.1)

# Plot the blue lines (URM students)
for index, row in df.iterrows():
    if row['race'] == 'URM':
        plot.line(dimensions, [row[dim] for dim in dimensions], line_color='blue', legend_label=row['race'], line_width=0.1)

# Calculate average prerequisite and subsequent scores for URM students
avg_prereq_score_urm = df[df['race'] == 'URM']['prereq_score'].mean()
avg_subseq_score_urm = df[df['race'] == 'URM']['subseq_score'].mean()
avg_prereq_score_nonurm = df[df['race'] == 'Non-URM']['prereq_score'].mean()
avg_subseq_score_nonurm = df[df['race'] == 'Non-URM']['subseq_score'].mean()

# Plot the average lines for URM and Non-URM students
plot.line(dimensions, [avg_prereq_score_urm, avg_subseq_score_urm], line_width=2, line_color='yellow', legend_label='Average Grade')
plot2.line(dimensions, [avg_prereq_score_nonurm, avg_subseq_score_nonurm], line_width=2, line_color='yellow', legend_label='Average Grade')

# Customize plot properties
plot.xaxis.axis_label = "Prerequisite vs. Subsequent"
plot.yaxis.axis_label = "Grade Earned"
plot2.xaxis.axis_label = "Prerequisite vs. Subsequent"
plot2.yaxis.axis_label = "Grade Earned"
plot.legend.location = "bottom_right"
plot2.legend.location = "bottom_right"

# Define function to classify grades as improved or worsened
def classify_grade_change(row):
    if row['subseq_score'] >= row['prereq_score']:
        return 'Improved'
    else:
        return 'Worsened'

# Apply the function to create a new column in df to use for bar graph
df['grade_change'] = df.apply(classify_grade_change, axis=1)

# Group data by URM status and grade change
grouped_data = df.groupby(['race', 'grade_change']).size().unstack(fill_value=0)

# Extract counts for URM: Yes and No for improved and worsened grades
urm_improved = grouped_data.loc['URM', 'Improved']
urm_worsened = grouped_data.loc['URM', 'Worsened']
non_urm_improved = grouped_data.loc['Non-URM', 'Improved']
non_urm_worsened = grouped_data.loc['Non-URM', 'Worsened']

#Get percentages of improved/worsened for each population
urm_improved_percentage = urm_improved/NUM_URMS
urm_worsened_percentage = urm_worsened/NUM_URMS
non_urm_improved_percentage = non_urm_improved/NUM_NONS
non_urm_worsened_percentage = non_urm_worsened/NUM_NONS
student_types = ['URM', 'Non-URM']
student_subtypes = ["Improved", "Worsened"]

# Plot bars for URM and non-URM
#p1.vbar(x=['% Improved'], top=urm_improved_percentage, width=0.4, color='blue', legend_label='URM')
#p1.vbar(x=['% Improved_Non'], top=non_urm_improved_percentage, width=0.4, color='red', legend_label='Non-URM')
#p1.vbar(x=['% Worsened'], top=urm_worsened_percentage, width=0.4, color='blue')
#p1.vbar(x=['% Worsened_Non'], top=non_urm_worsened_percentage, width=0.4, color='red')

mini_df = {'student_types': student_types,
           'Improved': [urm_improved_percentage, non_urm_improved_percentage],
           'Worsened': [ urm_worsened_percentage, non_urm_worsened_percentage]}

# Create bar plot for URM vs non-URM
p1 = figure(title="Percentage improved/worsened for URM and Non-URM", x_range=student_types,
            height=250, y_range=(0.0, 1.0), toolbar_location=None, tools="")

v = p1.vbar_stack(student_subtypes, x='student_types', width=0.4,
                  color=['green', 'gray'], source=mini_df, legend_label=student_subtypes)

p1.legend.location = "bottom_center"
p1.xgrid.grid_line_color = None
p1.axis.minor_tick_line_color = None
p1.outline_line_color = None
p1.yaxis.axis_label = "% of respective population"
p1.xaxis.axis_label = "Population Group"
p1.legend.orientation = "vertical"

#grid = gridplot([[plot], [plot2], [p1]])

# Show the plot
output_notebook()
#show(column(checkbox_group, grid))
show(gridplot([[plot, plot2], [p1, None]]))